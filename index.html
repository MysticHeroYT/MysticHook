<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MysticHook</title>
  <!-- Load Tailwind CSS via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Load Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" xintegrity="sha512-Fo3rlrZj/k7sLw/dZt3Rz5sP/dZt3Rz5sP/f6KkF58pG9pGgG8+2pP+jJk2U2lK4yUu3QzB6K8CgC8vJ7vTf8lE/pL0NqP6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <!-- Custom Favicon (inline SVG) -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M50 0 C77.6 0 100 22.4 100 50 C100 77.6 77.6 100 50 100 C22.4 100 0 77.6 0 50 C0 22.4 22.4 0 50 0 Z' fill='%235865f2'/%3E%3Cpath d='M30 65 L45 80 L70 55 L55 40 Z' fill='%23fff'/%3E%3C/svg%3E">
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #1a202c;
    }
    .embed-preview {
        border-left-color: var(--embed-color);
    }
  </style>
</head>
<body class="bg-gray-900 text-white">
  <div id="root"></div>

  <!-- Corrected script loading order -->
  <!-- 1. Load React and ReactDOM from CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- 2. Load Babel Standalone to transpile the JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
  <!-- 3. The main React app script with type="text/babel" -->
  <script type="text/babel">
    const { useState, useEffect } = React;

    // Helper component for styled form inputs
    const InputGroup = ({ label, value, onChange, type = 'text', placeholder, isValid, required, children }) => (
      <div>
        <label className="block text-sm font-medium text-gray-300 mb-1">
          {label}
          {required && <span className="text-red-400">*</span>}
        </label>
        {type === 'textarea' ? (
          <textarea
            value={value}
            onChange={onChange}
            placeholder={placeholder}
            className="w-full p-2 rounded-md bg-gray-600 border border-transparent focus:border-blue-500 focus:outline-none resize-y"
          ></textarea>
        ) : type === 'select' ? (
          <select
            value={value}
            onChange={onChange}
            className="w-full p-2 rounded-md bg-gray-600 border border-transparent focus:border-blue-500 focus:outline-none"
          >
            {children}
          </select>
        ) : type === 'color' ? (
          <input
            type="color"
            value={value}
            onChange={onChange}
            className="w-full h-10 p-1 rounded-md bg-gray-600 border border-transparent focus:border-blue-500 focus:outline-none"
          />
        ) : (
          <input
            type={type}
            value={value}
            onChange={onChange}
            placeholder={placeholder}
            className={`w-full p-2 rounded-md bg-gray-600 border ${
              isValid === false ? 'border-red-500' : 'border-transparent'
            } focus:border-blue-500 focus:outline-none`}
          />
        )}
      </div>
    );
    
    // Custom SVG icon as a data URL
    const mysticHookIconUrl = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M50 0 C77.6 0 100 22.4 100 50 C100 77.6 77.6 100 50 100 C22.4 100 0 77.6 0 50 C0 22.4 22.4 0 50 0 Z' fill='%235865f2'/%3E%3Cpath d='M30 65 L45 80 L70 55 L55 40 Z' fill='%23fff'/%3E%3C/svg%3E";

    // Fallback avatar as an inline SVG
    const defaultAvatarSvg = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white" width="48px" height="48px"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>`;

    // Initial state for the app, now with an empty embeds array
    const initialAppState = {
      embeds: [],
      currentEmbedIndex: 0,
      components: [],
      messageContent: '',
      username: 'MysticHook',
      avatarUrl: '',
      webhookUrl: '',
      isWebhookValid: false,
      tts: false,
      threadId: '',
      messageId: '',
      file: null,
      audioFile: null,
      isRecording: false,
      recorder: null,
      statusMessage: '',
      liveUsername: '',
      liveAvatarUrl: '',
      audioBlob: null,
      isAvatarLoading: false
    };

    const App = () => {
      // Core webhook state
      const [appState, setAppState] = useState(initialAppState);

      // Destructure state for easier access
      const { 
        embeds, currentEmbedIndex, components, messageContent, username, avatarUrl,
        webhookUrl, isWebhookValid, tts, threadId, messageId, file, audioFile,
        isRecording, recorder, statusMessage, liveUsername, liveAvatarUrl, audioBlob,
        isAvatarLoading
      } = appState;

      // Effect to validate the webhook URL and fetch its info
      useEffect(() => {
        const isValid = webhookUrl.startsWith('https://discord.com/api/webhooks/');
        setAppState(prevState => ({ ...prevState, isWebhookValid: isValid }));
        
        if (isValid) {
          setAppState(prevState => ({ ...prevState, isAvatarLoading: true }));
          fetch(webhookUrl, { method: 'GET' })
            .then(response => {
              if (response.ok) {
                return response.json();
              } else {
                throw new Error('Failed to fetch webhook data');
              }
            })
            .then(data => {
              const newLiveUsername = data.name;
              const avatar = data.avatar;
              let newLiveAvatarUrl = '';
              if (avatar) {
                const extension = avatar.startsWith('a_') ? 'gif' : 'png';
                newLiveAvatarUrl = `https://cdn.discordapp.com/avatars/${data.id}/${avatar}.${extension}`;
              }
              setAppState(prevState => ({ 
                ...prevState, 
                liveUsername: newLiveUsername, 
                liveAvatarUrl: newLiveAvatarUrl,
                isAvatarLoading: false
              }));
            })
            .catch(error => {
              console.error("Error fetching webhook info:", error);
              setAppState(prevState => ({ ...prevState, liveUsername: '', liveAvatarUrl: '', isAvatarLoading: false }));
            });
        } else {
          setAppState(prevState => ({ ...prevState, liveUsername: '', liveAvatarUrl: '' }));
        }
      }, [webhookUrl]);
      
      // Function to clear all data and reset to initial state
      const clearAllData = () => {
        setAppState(initialAppState);
      };

      // State management for embeds and fields
      const handleEmbedChange = (field, value) => {
        const newEmbeds = [...embeds];
        newEmbeds[currentEmbedIndex] = { ...newEmbeds[currentEmbedIndex], [field]: value };
        setAppState(prevState => ({ ...prevState, embeds: newEmbeds }));
      };

      const handleFieldChange = (fieldIndex, fieldName, value) => {
        const newEmbeds = [...embeds];
        const newFields = [...(newEmbeds[currentEmbedIndex].fields || [])];
        if (!newFields[fieldIndex]) {
          newFields[fieldIndex] = {};
        }
        newFields[fieldIndex][fieldName] = value;
        newEmbeds[currentEmbedIndex].fields = newFields;
        setAppState(prevState => ({ ...prevState, embeds: newEmbeds }));
      };

      const addEmbed = () => {
        setAppState(prevState => ({ 
          ...prevState, 
          embeds: [...prevState.embeds, { title: '', description: '', color: '', fields: [] }],
          currentEmbedIndex: prevState.embeds.length
        }));
      };

      const removeEmbed = (index) => {
        const newEmbeds = embeds.filter((_, i) => i !== index);
        let newCurrentIndex = currentEmbedIndex;
        if (newCurrentIndex >= newEmbeds.length) {
          newCurrentIndex = newEmbeds.length > 0 ? newEmbeds.length - 1 : 0;
        }
        setAppState(prevState => ({ ...prevState, embeds: newEmbeds, currentEmbedIndex: newCurrentIndex }));
      };

      const addField = () => {
        const newEmbeds = [...embeds];
        const currentFields = newEmbeds[currentEmbedIndex].fields || [];
        newEmbeds[currentEmbedIndex].fields = [...currentFields, { name: '', value: '', inline: false }];
        setAppState(prevState => ({ ...prevState, embeds: newEmbeds }));
      };

      const removeField = (fieldIndex) => {
        const newEmbeds = [...embeds];
        newEmbeds[currentEmbedIndex].fields = newEmbeds[currentEmbedIndex].fields.filter((_, i) => i !== fieldIndex);
        setAppState(prevState => ({ ...prevState, embeds: newEmbeds }));
      };

      // State management for components (buttons/select menus)
      const addComponent = () => {
        setAppState(prevState => ({
          ...prevState,
          components: [...prevState.components, { type: 'button', label: '', style: 1, custom_id: '', url: '' }]
        }));
      };

      const removeComponent = (index) => {
        const newComponents = components.filter((_, i) => i !== index);
        setAppState(prevState => ({ ...prevState, components: newComponents }));
      };

      const handleComponentChange = (index, field, value) => {
        const newComponents = [...components];
        newComponents[index] = { ...newComponents[index], [field]: value };
        setAppState(prevState => ({ ...prevState, components: newComponents }));
      };
      
      const handleFileChange = (e) => {
        setAppState(prevState => ({ ...prevState, file: e.target.files[0] }));
      };

      // Function to send the webhook with detailed logging and robust data cleaning
      const sendWebhook = async () => {
        console.log("Starting webhook send process...");

        if (!webhookUrl || !isWebhookValid) {
          console.error("Validation failed: Webhook URL is not valid or is empty.");
          setAppState(prevState => ({ ...prevState, statusMessage: "Please enter a valid Webhook URL." }));
          return;
        }

        // --- Start of Robust Data Cleaning ---
        const cleanedEmbeds = [];
        for (const embed of embeds) {
          const cleanedFields = [];
          for (const field of embed.fields || []) {
            // Check for valid field name and value
            if (field.name && field.name.trim() !== '' && field.value && field.value.trim() !== '') {
              cleanedFields.push(field);
            } else {
              console.warn("Skipping invalid field:", field);
            }
          }

          // Check if embed itself has any meaningful content
          if (embed.title || embed.description || embed.url || cleanedFields.length > 0) {
            cleanedEmbeds.push({
              ...embed,
              fields: cleanedFields,
            });
          } else {
            console.warn("Skipping empty embed:", embed);
          }
        }
        
        // Clean and prepare components for the payload
        const cleanedComponents = components.map(c => {
          if (c.style == 5) {
            // Link button
            return {
              type: 2,
              style: c.style,
              label: c.label,
              url: c.url,
            };
          } else {
            // Interactive button
            return {
              type: 2,
              style: c.style,
              label: c.label,
              custom_id: c.custom_id,
            };
          }
        });
        
        // Final payload construction
        const payload = {
          content: messageContent,
          username: username,
          avatar_url: avatarUrl,
          tts: tts,
          // Only include embeds and components if they have valid content
          ...(cleanedEmbeds.length > 0 && { embeds: cleanedEmbeds }),
          ...(cleanedComponents.length > 0 && {
            components: [{
              type: 1, // ActionRow
              components: cleanedComponents
            }]
          })
        };

        // If the payload has no content, embeds, or components, warn the user
        if (!payload.content && (!payload.embeds || payload.embeds.length === 0) && (!payload.components || payload.components.length === 0) && !file && !audioFile) {
          setAppState(prevState => ({ ...prevState, statusMessage: "Payload is empty. Please add content, embeds, or components." }));
          return;
        }

        console.log("Final payload to be sent:", payload);

        let body;
        let headers = {};
        
        // Check if there is a file to send
        if (file || audioFile) {
          const formData = new FormData();
          formData.append('payload_json', JSON.stringify(payload));
          if (file) {
            formData.append('file', file);
          }
          if (audioFile) {
            formData.append('file', audioFile, 'voice_message.webm');
          }
          body = formData;
          console.log("Preparing to send with FormData because a file is present.");
        } else {
          body = JSON.stringify(payload);
          headers['Content-Type'] = 'application/json';
          console.log("Preparing to send with JSON body.");
        }

        setAppState(prevState => ({ ...prevState, statusMessage: "Sending..." }));
        
        try {
          const url = new URL(webhookUrl);
          if (threadId) {
            url.searchParams.append('thread_id', threadId);
          }
          if (messageId) {
            url.searchParams.append('wait', 'true');
          }
          
          console.log("Sending POST request to:", url.href);

          const response = await fetch(url.href, {
            method: 'POST',
            headers: headers,
            body: body,
          });

          if (response.ok) {
            console.log("Webhook sent successfully!");
            setAppState(prevState => ({ ...prevState, statusMessage: "Webhook sent successfully!" }));
          } else {
            const errorText = await response.text();
            console.error(`Webhook failed with status ${response.status}: ${response.statusText}`);
            console.error("Detailed error response:", errorText);
            setAppState(prevState => ({ ...prevState, statusMessage: `Error sending webhook: ${response.status} ${response.statusText}. Details: ${errorText}` }));
          }
        } catch (error) {
          console.error("An unhandled network or API error occurred:", error);
          setAppState(prevState => ({ ...prevState, statusMessage: `Failed to send webhook. Check the URL and try again.` }));
        }
      };

      // Function to generate and play TTS audio
      const generateTTS = async () => {
        if (!messageContent) {
          setAppState(prevState => ({ ...prevState, statusMessage: "Please enter a message to generate TTS." }));
          return;
        }

        const payload = {
          contents: [{
            parts: [{ text: messageContent }]
          }],
          generationConfig: {
            responseModality: "AUDIO",
            speechConfig: {
              voiceConfig: {
                prebuiltVoiceConfig: { voiceName: "Kore" }
              }
            }
          },
          model: "gemini-2.5-flash-preview-tts"
        };
        const apiKey = ""; // Canvas will provide this
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
        
        setAppState(prevState => ({ ...prevState, statusMessage: "Generating TTS audio..." }));
        try {
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            throw new Error(`API request failed with status: ${response.status}`);
          }

          const result = await response.json();
          const part = result?.candidates?.[0]?.content?.parts?.[0];
          const audioData = part?.inlineData?.data;
          const mimeType = part?.inlineData?.mimeType;
          
          if (audioData && mimeType && mimeType.startsWith("audio/")) {
            const pcmData = atob(audioData);
            const pcmBuffer = new ArrayBuffer(pcmData.length);
            const pcmView = new Uint8Array(pcmBuffer);
            for (let i = 0; i < pcmData.length; i++) {
              pcmView[i] = pcmData.charCodeAt(i);
            }

            const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
            const pcm16 = new Int16Array(pcmBuffer.buffer);
            const wavBlob = pcmToWav(pcm16, sampleRate);
            const audioUrl = URL.createObjectURL(wavBlob);
            
            const audio = new Audio(audioUrl);
            audio.play();
            setAppState(prevState => ({ ...prevState, statusMessage: "TTS audio is playing..." }));
            audio.onended = () => setAppState(prevState => ({ ...prevState, statusMessage: "TTS playback finished." }));

          } else {
            setAppState(prevState => ({ ...prevState, statusMessage: "TTS generation failed. No audio data received." }));
          }

        } catch (error) {
          console.error("Error generating or playing TTS:", error);
          setAppState(prevState => ({ ...prevState, statusMessage: `TTS Error: ${error.message}` }));
        }
      };

      // Helper function to convert PCM to WAV format
      const pcmToWav = (pcm16, sampleRate) => {
        const dataLength = pcm16.length * 2; // 16-bit PCM
        const buffer = new ArrayBuffer(44 + dataLength);
        const view = new DataView(buffer);

        let offset = 0;

        // RIFF header
        writeString(view, offset, 'RIFF');
        offset += 4;
        view.setUint32(offset, 36 + dataLength, true);
        offset += 4;
        writeString(view, offset, 'WAVE');
        offset += 4;

        // fmt sub-chunk
        writeString(view, offset, 'fmt ');
        offset += 4;
        view.setUint32(offset, 16, true);
        offset += 4;
        view.setUint16(offset, 1, true); // AudioFormat: PCM
        offset += 2;
        view.setUint16(offset, 1, true); // NumChannels
        offset += 2;
        view.setUint32(offset, sampleRate, true); // SampleRate
        offset += 4;
        view.setUint32(offset, sampleRate * 2, true); // ByteRate
        offset += 4;
        view.setUint16(offset, 2, true); // BlockAlign
        offset += 2;
        view.setUint16(offset, 16, true); // BitsPerSample
        offset += 2;

        // data sub-chunk
        writeString(view, offset, 'data');
        offset += 4;
        view.setUint32(offset, dataLength, true);
        offset += 4;

        // Write PCM data
        for (let i = 0; i < pcm16.length; i++, offset += 2) {
          view.setInt16(offset, pcm16[i], true);
        }

        return new Blob([view], { type: 'audio/wav' });
      };

      const writeString = (view, offset, string) => {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      };

      // Function to parse and render Markdown to HTML
      const renderMarkdown = (text) => {
        if (!text) return '';
        let html = text;
        // Convert bold markdown (**text** or __text__) to <strong>
        html = html.replace(/\*\*(.*?)\*\*|__(.*?)__/g, '<strong>$1$2</strong>');
        // Convert heading (# text) to <h1>
        html = html.replace(/^#\s(.+)/gm, '<h1 class="text-xl font-bold">$1</h1>');
        return html;
      };
      
      const Preview = () => {
        const previewEmbed = embeds[currentEmbedIndex] || {};
        
        return (
          <div className="w-full lg:w-1/2 p-4 lg:p-8 bg-gray-800 rounded-xl shadow-lg flex flex-col h-full">
            <h2 className="text-xl font-extrabold text-blue-400 mb-6">Live Preview</h2>
            <div className="flex-1 overflow-y-auto p-4 bg-gray-700 rounded-lg">
                <div className="flex items-start mb-4">
                    <img src={displayAvatarUrl || defaultAvatarSvg} alt="User Avatar" 
                         className={`w-12 h-12 rounded-full mr-4 ${isAvatarLoading ? 'animate-pulse bg-gray-600' : ''}`} 
                         onError={(e) => { e.target.src = defaultAvatarSvg; }} />
                    <div>
                        <div className="flex items-baseline">
                            <span className="font-semibold text-gray-100">{displayUsername}</span>
                            <span className="text-xs text-gray-400 ml-2">Today at {new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}</span>
                        </div>
                        {messageContent && (
                            <div className="text-gray-200 mt-1" dangerouslySetInnerHTML={{ __html: renderMarkdown(messageContent) }} />
                        )}
                        {audioBlob && (
                          <div className="mt-2 flex items-center bg-gray-800 p-2 rounded-lg">
                              <i className="fas fa-volume-up text-blue-400 mr-2"></i>
                              <span className="text-sm text-gray-300">Voice Message Preview</span>
                              <button onClick={playAudio} className="ml-4 text-blue-400 hover:text-blue-500">
                                  <i className="fas fa-play"></i>
                              </button>
                          </div>
                        )}
                        {file && (
                           <div className="mt-2 flex items-center bg-gray-800 p-2 rounded-lg">
                               <i className="fas fa-file-upload text-blue-400 mr-2"></i>
                               <span className="text-sm text-gray-300">{file.name}</span>
                           </div>
                        )}
                        {embeds.length > 0 && embeds.map((embed, index) => (
                           <div key={index} className="mt-2 p-3 rounded-lg border-l-4" style={{ borderColor: embed.color || '#5865F2' }}>
                               {embed.title && <h3 className="font-bold text-gray-100">{embed.title}</h3>}
                               {embed.description && <p className="text-sm text-gray-300 mt-1">{embed.description}</p>}
                               <div className="mt-2 grid grid-cols-1 md:grid-cols-2 gap-4">
                                   {(embed.fields || []).map((field, fieldIndex) => (
                                       <div key={fieldIndex} className={`${field.inline ? '' : 'col-span-2'}`}>
                                           <h4 className="font-semibold text-gray-200">{field.name}</h4>
                                           <p className="text-sm text-gray-400">{field.value}</p>
                                       </div>
                                   ))}
                               </div>
                           </div>
                       ))}
                       {components.length > 0 && (
                            <div className="mt-4 flex flex-wrap gap-2">
                                {components.map((comp, index) => (
                                    <button
                                        key={index}
                                        className={`px-4 py-2 rounded-md font-semibold transition-colors duration-200 
                                            ${comp.style == 1 ? 'bg-blue-600 hover:bg-blue-700 text-white' : ''}
                                            ${comp.style == 2 ? 'bg-gray-600 hover:bg-gray-700 text-white' : ''}
                                            ${comp.style == 3 ? 'bg-green-600 hover:bg-green-700 text-white' : ''}
                                            ${comp.style == 4 ? 'bg-red-600 hover:bg-red-700 text-white' : ''}
                                            ${comp.style == 5 ? 'text-blue-400 hover:underline' : ''}`}
                                    >
                                        {comp.label}
                                    </button>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            </div>
            
            {/* Status message at the bottom of the preview */}
            <div className="mt-4 text-center">
                <p className={`text-sm ${statusMessage.includes('Error') ? 'text-red-400' : 'text-green-400'}`}>{statusMessage}</p>
            </div>
          </div>
        )
      }

      // Voice message recording functions
      const startRecording = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const newRecorder = new MediaRecorder(stream);
          let audioChunks = [];
          newRecorder.ondataavailable = event => {
            audioChunks.push(event.data);
          };
          newRecorder.onstop = () => {
            const newAudioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            setAppState(prevState => ({ ...prevState, audioBlob: newAudioBlob, audioFile: newAudioBlob, statusMessage: "Recording stopped. Audio saved." }));
            stream.getTracks().forEach(track => track.stop());
          };
          newRecorder.start();
          setAppState(prevState => ({ ...prevState, recorder: newRecorder, isRecording: true, statusMessage: "Recording started..." }));
        } catch (err) {
          console.error('Failed to start recording:', err);
          setAppState(prevState => ({ ...prevState, statusMessage: "Error: Failed to start recording. Ensure you have a microphone." }));
        }
      };
      
      const stopRecording = () => {
        if (recorder) {
          recorder.stop();
          setAppState(prevState => ({ ...prevState, isRecording: false }));
        }
      };

      const playAudio = () => {
        if (audioBlob) {
          const audioUrl = URL.createObjectURL(audioBlob);
          const audio = new Audio(audioUrl);
          audio.play();
          setAppState(prevState => ({ ...prevState, statusMessage: "Playing voice message..." }));
          audio.onended = () => setAppState(prevState => ({ ...prevState, statusMessage: "Voice message playback finished." }));
        }
      };

      // Choose which username and avatar to display
      const displayUsername = liveUsername || username || 'MysticHook';
      const displayAvatarUrl = avatarUrl || liveAvatarUrl || '';
      
      return (
        <div className="flex flex-col lg:flex-row h-full min-h-screen bg-gray-900 text-gray-100 p-4 lg:p-8">
          {/* Left Panel: Controls */}
          <div className="w-full lg:w-1/2 p-4 bg-gray-800 rounded-xl shadow-lg mb-8 lg:mb-0 lg:mr-4 overflow-y-auto">
            <h1 className="text-3xl font-extrabold text-blue-400 mb-6 flex items-center">
              <img src={mysticHookIconUrl} alt="MysticHook Icon" className="w-8 h-8 mr-3"/>
              MysticHook
            </h1>
            <p className="text-gray-400 mb-6 text-sm">Create and customize Discord webhook messages with rich embeds and components.</p>

            {/* General Settings */}
            <div className="bg-gray-700 p-4 rounded-lg mb-6">
              <h2 className="text-xl font-bold mb-3 text-white">General Settings</h2>
              <div className="space-y-4">
                <InputGroup
                  label="Webhook URL"
                  value={webhookUrl}
                  onChange={(e) => setAppState(prevState => ({ ...prevState, webhookUrl: e.target.value }))}
                  type="url"
                  placeholder="https://discord.com/api/webhooks/..."
                  required
                  isValid={isWebhookValid}
                />
                <InputGroup label="Username" value={username} onChange={(e) => setAppState(prevState => ({ ...prevState, username: e.target.value }))} placeholder="MysticHook" />
                <InputGroup label="Avatar URL" value={avatarUrl} onChange={(e) => setAppState(prevState => ({ ...prevState, avatarUrl: e.target.value }))} type="url" placeholder="https://..." />
                <InputGroup label="Message Content" value={messageContent} onChange={(e) => setAppState(prevState => ({ ...prevState, messageContent: e.target.value }))} type="textarea" placeholder="Hello, this is my webhook message!" />
                <InputGroup label="Thread ID (Optional)" value={threadId} onChange={(e) => setAppState(prevState => ({ ...prevState, threadId: e.target.value }))} placeholder="e.g. 1234567890" />
                <div className="flex items-center">
                  <input type="checkbox" id="ttsCheckbox" checked={tts} onChange={(e) => setAppState(prevState => ({ ...prevState, tts: e.target.checked }))} className="form-checkbox h-5 w-5 text-blue-600 rounded" />
                  <label htmlFor="ttsCheckbox" className="ml-2 text-gray-300">Text-to-Speech (TTS)</label>
                </div>
              </div>
            </div>

            {/* Embeds Section */}
            <div className="bg-gray-700 p-4 rounded-lg mb-6">
              <h2 className="text-xl font-bold mb-3 text-white flex justify-between items-center">
                Embeds ({embeds.length})
                <button onClick={addEmbed} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-full transition-colors duration-200">
                  + Add
                </button>
              </h2>
              {embeds.length > 0 && (
                <div className="space-y-4">
                  <div className="flex space-x-2 overflow-x-auto pb-2">
                    {embeds.map((_, index) => (
                      <button
                        key={index}
                        onClick={() => setAppState(prevState => ({ ...prevState, currentEmbedIndex: index }))}
                        className={`px-4 py-2 rounded-lg transition-colors duration-200 ${
                          currentEmbedIndex === index ? 'bg-blue-600 text-white' : 'bg-gray-600 hover:bg-gray-500 text-gray-300'
                        }`}
                      >
                        Embed {index + 1}
                      </button>
                    ))}
                  </div>
                  {embeds[currentEmbedIndex] && (
                    <div className="p-4 bg-gray-600 rounded-lg">
                      <div className="flex justify-between items-center mb-4">
                        <h3 className="text-lg font-semibold text-white">Embed {currentEmbedIndex + 1}</h3>
                        <button onClick={() => removeEmbed(currentEmbedIndex)} className="text-red-400 hover:text-red-500">
                          <i className="fas fa-trash-alt"></i>
                        </button>
                      </div>
                      <div className="space-y-4">
                        <InputGroup label="Title" value={embeds[currentEmbedIndex].title || ''} onChange={(e) => handleEmbedChange('title', e.target.value)} placeholder="Embed Title" />
                        <InputGroup label="Description" value={embeds[currentEmbedIndex].description || ''} onChange={(e) => handleEmbedChange('description', e.target.value)} type="textarea" placeholder="Embed Description" />
                        <InputGroup label="URL" value={embeds[currentEmbedIndex].url || ''} onChange={(e) => handleEmbedChange('url', e.target.value)} type="url" placeholder="https://..." />
                        <InputGroup label="Color" value={embeds[currentEmbedIndex].color || ''} onChange={(e) => handleEmbedChange('color', e.target.value)} type="color" />
                        
                        {/* Fields Section */}
                        <div className="bg-gray-500 p-4 rounded-lg">
                          <div className="flex justify-between items-center mb-3">
                            <h4 className="font-semibold text-white">Fields</h4>
                            <button onClick={addField} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-full transition-colors duration-200 text-sm">
                              + Add Field
                            </button>
                          </div>
                          {(embeds[currentEmbedIndex].fields || []).map((field, fieldIndex) => (
                            <div key={fieldIndex} className="bg-gray-400 p-3 rounded-lg mb-2 last:mb-0">
                              <div className="flex justify-between items-center mb-2">
                                <span className="text-sm font-medium text-gray-800">Field {fieldIndex + 1}</span>
                                <button onClick={() => removeField(fieldIndex)} className="text-red-600 hover:text-red-700">
                                  <i className="fas fa-times"></i>
                                </button>
                              </div>
                              <InputGroup label="Name" value={field.name} onChange={(e) => handleFieldChange(fieldIndex, 'name', e.target.value)} placeholder="Field Name" />
                              <InputGroup label="Value" value={field.value} onChange={(e) => handleFieldChange(fieldIndex, 'value', e.target.value)} type="textarea" placeholder="Field Value" />
                              <div className="flex items-center mt-2">
                                <input type="checkbox" id={`inline-${currentEmbedIndex}-${fieldIndex}`} checked={field.inline} onChange={(e) => handleFieldChange(fieldIndex, 'inline', e.target.checked)} className="form-checkbox h-4 w-4 text-blue-600 rounded" />
                                <label htmlFor={`inline-${currentEmbedIndex}-${fieldIndex}`} className="ml-2 text-gray-800 text-sm">Inline</label>
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>

            {/* Components Section */}
            <div className="bg-gray-700 p-4 rounded-lg mb-6">
              <h2 className="text-xl font-bold mb-3 text-white flex justify-between items-center">
                Components ({components.length})
                <button onClick={addComponent} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-full transition-colors duration-200">
                  + Add
                </button>
              </h2>
              {components.map((component, index) => (
                <div key={index} className="bg-gray-600 p-4 rounded-lg mb-4">
                  <div className="flex justify-between items-center mb-3">
                    <h3 className="text-lg font-semibold text-white">Component {index + 1}</h3>
                    <button onClick={() => removeComponent(index)} className="text-red-400 hover:text-red-500">
                      <i className="fas fa-trash-alt"></i>
                    </button>
                  </div>
                  <div className="space-y-3">
                    <InputGroup label="Type" value={component.type} onChange={(e) => handleComponentChange(index, 'type', e.target.value)} type="select">
                      <option value="button">Button</option>
                      {/* Select menus can be added here if needed */}
                    </InputGroup>
                    <InputGroup label="Label" value={component.label} onChange={(e) => handleComponentChange(index, 'label', e.target.value)} placeholder="Button Label" />
                    <InputGroup label="Style" value={component.style} onChange={(e) => handleComponentChange(index, 'style', e.target.value)} type="select">
                      <option value="1">Primary</option>
                      <option value="2">Secondary</option>
                      <option value="3">Success</option>
                      <option value="4">Danger</option>
                      <option value="5">Link</option>
                    </InputGroup>
                    {component.style == 5 ? (
                      <InputGroup label="URL" value={component.url} onChange={(e) => handleComponentChange(index, 'url', e.target.value)} type="url" placeholder="https://..." />
                    ) : (
                      <InputGroup label="Custom ID" value={component.custom_id} onChange={(e) => handleComponentChange(index, 'custom_id', e.target.value)} placeholder="e.g. unique_button_id" />
                    )}
                  </div>
                </div>
              ))}
            </div>

            {/* File Upload Section */}
            <div className="bg-gray-700 p-4 rounded-lg mb-6">
              <h2 className="text-xl font-bold mb-3 text-white">File Upload</h2>
              <input type="file" onChange={handleFileChange} className="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-500 file:text-white hover:file:bg-blue-600"/>
              {file && (
                <p className="mt-2 text-sm text-gray-400">Selected file: {file.name}</p>
              )}
            </div>
            
            {/* Audio Recording Section */}
            <div className="bg-gray-700 p-4 rounded-lg mb-6 flex flex-col items-center">
              <h2 className="text-xl font-bold mb-3 text-white">Voice Message</h2>
              <div className="flex items-center space-x-4">
                <button
                  onClick={isRecording ? stopRecording : startRecording}
                  className={`py-3 px-6 rounded-full text-white font-bold transition-all duration-300 ease-in-out transform hover:scale-105 ${isRecording ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600'}`}
                >
                  {isRecording ? <i className="fas fa-stop"></i> : <i className="fas fa-microphone"></i>}
                  <span className="ml-2">{isRecording ? 'Stop Recording' : 'Start Recording'}</span>
                </button>
                {audioBlob && (
                  <button onClick={playAudio} className="py-3 px-6 rounded-full bg-blue-500 hover:bg-blue-600 text-white font-bold transition-transform duration-300 ease-in-out transform hover:scale-105">
                    <i className="fas fa-play"></i>
                    <span className="ml-2">Play</span>
                  </button>
                )}
                <button onClick={generateTTS} className="py-3 px-6 rounded-full bg-blue-500 hover:bg-blue-600 text-white font-bold transition-transform duration-300 ease-in-out transform hover:scale-105">
                    <i className="fas fa-volume-up"></i>
                    <span className="ml-2">TTS</span>
                </button>
              </div>
            </div>

            {/* Action Buttons */}
            <div className="bg-gray-700 p-4 rounded-lg flex flex-col sm:flex-row justify-between items-center space-y-4 sm:space-y-0 sm:space-x-4">
                <button
                    onClick={sendWebhook}
                    className="w-full sm:w-auto px-6 py-3 rounded-lg font-bold text-white bg-blue-600 hover:bg-blue-700 transition-colors duration-200 transform hover:scale-105"
                >
                    <i className="fas fa-paper-plane mr-2"></i>
                    Send Webhook
                </button>
                <button
                    onClick={clearAllData}
                    className="w-full sm:w-auto px-6 py-3 rounded-lg font-bold text-gray-300 bg-gray-600 hover:bg-gray-500 transition-colors duration-200 transform hover:scale-105"
                >
                    <i className="fas fa-eraser mr-2"></i>
                    Clear All
                </button>
            </div>
          </div>
          
          {/* Right Panel: Live Preview */}
          <Preview />
        </div>
      );
    };

    // The root of the React app
    // Using the modern createRoot method, which is the correct way to render in React 18+
    const domNode = document.getElementById('root');
    const root = ReactDOM.createRoot(domNode);
    root.render(<App />);

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MysticHook</title>
  <!-- Load Tailwind CSS via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Load Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" xintegrity="sha512-Fo3rlrZj/k7sLw/dZt3Rz5sP/f6KkF58pG9pGgG8+2pP+jJk2U2lK4yUu3QzB6K8CgC8vJ7vTf8lE/pL0NqP6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <!-- Custom Favicon (inline SVG) -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M50 0 C77.6 0 100 22.4 100 50 C100 77.6 77.6 100 50 100 C22.4 100 0 77.6 0 50 C0 22.4 22.4 0 50 0 Z' fill='%235865f2'/%3E%3Cpath d='M30 65 L45 80 L70 55 L55 40 Z' fill='%23fff'/%3E%3C/svg%3E">
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #1a202c;
    }
  </style>
</head>
<body class="bg-gray-900 text-white">
  <div id="root"></div>

  <!-- Load React and ReactDOM from CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- The main React app script, now using Babel -->
  <script type="text/babel">
    const { useState, useEffect } = React;

    // A simple tooltip component
    const Tooltip = ({ text, children }) => (
      <div className="relative group inline-block">
        {children}
        <span className="absolute left-1/2 -translate-x-1/2 bottom-full mb-2 px-3 py-1 bg-gray-600 text-white text-xs rounded-md whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity duration-300">
          {text}
        </span>
      </div>
    );
    
    // Custom SVG icon as a data URL
    const mysticHookIconUrl = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M50 0 C77.6 0 100 22.4 100 50 C100 77.6 77.6 100 50 100 C22.4 100 0 77.6 0 50 C0 22.4 22.4 0 50 0 Z' fill='%235865f2'/%3E%3Cpath d='M30 65 L45 80 L70 55 L55 40 Z' fill='%23fff'/%3E%3C/svg%3E";

    // Fallback avatar as an inline SVG
    const defaultAvatarSvg = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white" width="48px" height="48px"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>`;

    // Initial state for the app, now with an empty embeds array
    const initialAppState = {
      embeds: [],
      currentEmbedIndex: 0,
      components: [],
      messageContent: '',
      username: 'MysticHook',
      avatarUrl: '',
      webhookUrl: '',
      isWebhookValid: false,
      tts: false,
      threadId: '',
      messageId: '',
      file: null,
      audioFile: null,
      isRecording: false,
      recorder: null,
      statusMessage: '',
      liveUsername: '',
      liveAvatarUrl: '',
      audioBlob: null,
      isAvatarLoading: false
    };

    const App = () => {
      // Core webhook state
      const [appState, setAppState] = useState(initialAppState);

      // Destructure state for easier access
      const { 
        embeds, currentEmbedIndex, components, messageContent, username, avatarUrl,
        webhookUrl, isWebhookValid, tts, threadId, messageId, file, audioFile,
        isRecording, recorder, statusMessage, liveUsername, liveAvatarUrl, audioBlob,
        isAvatarLoading
      } = appState;

      // Effect to validate the webhook URL and fetch its info
      useEffect(() => {
        const isValid = webhookUrl.startsWith('https://discord.com/api/webhooks/');
        setAppState(prevState => ({ ...prevState, isWebhookValid: isValid }));
        
        if (isValid) {
          setAppState(prevState => ({ ...prevState, isAvatarLoading: true }));
          fetch(webhookUrl, { method: 'GET' })
            .then(response => {
              if (response.ok) {
                return response.json();
              } else {
                throw new Error('Failed to fetch webhook data');
              }
            })
            .then(data => {
              const newLiveUsername = data.name;
              const avatar = data.avatar;
              let newLiveAvatarUrl = '';
              if (avatar) {
                const extension = avatar.startsWith('a_') ? 'gif' : 'png';
                newLiveAvatarUrl = `https://cdn.discordapp.com/avatars/${data.id}/${avatar}.${extension}`;
              }
              setAppState(prevState => ({ 
                ...prevState, 
                liveUsername: newLiveUsername, 
                liveAvatarUrl: newLiveAvatarUrl,
                isAvatarLoading: false
              }));
            })
            .catch(error => {
              console.error("Error fetching webhook info:", error);
              setAppState(prevState => ({ ...prevState, liveUsername: '', liveAvatarUrl: '', isAvatarLoading: false }));
            });
        } else {
          setAppState(prevState => ({ ...prevState, liveUsername: '', liveAvatarUrl: '' }));
        }
      }, [webhookUrl]);
      
      // Function to clear all data and reset to initial state
      const clearAllData = () => {
        setAppState(initialAppState);
      };

      // State management for embeds and fields
      const handleEmbedChange = (field, value) => {
        const newEmbeds = [...embeds];
        newEmbeds[currentEmbedIndex] = { ...newEmbeds[currentEmbedIndex], [field]: value };
        setAppState(prevState => ({ ...prevState, embeds: newEmbeds }));
      };

      const handleFieldChange = (fieldIndex, fieldName, value) => {
        const newEmbeds = [...embeds];
        const newFields = [...(newEmbeds[currentEmbedIndex].fields || [])];
        if (!newFields[fieldIndex]) {
          newFields[fieldIndex] = {};
        }
        newFields[fieldIndex][fieldName] = value;
        newEmbeds[currentEmbedIndex].fields = newFields;
        setAppState(prevState => ({ ...prevState, embeds: newEmbeds }));
      };

      const addEmbed = () => {
        setAppState(prevState => ({ 
          ...prevState, 
          embeds: [...prevState.embeds, { title: '', description: '', color: '', fields: [] }],
          currentEmbedIndex: prevState.embeds.length
        }));
      };

      const removeEmbed = (index) => {
        const newEmbeds = embeds.filter((_, i) => i !== index);
        let newCurrentIndex = currentEmbedIndex;
        if (newCurrentIndex >= newEmbeds.length) {
          newCurrentIndex = newEmbeds.length > 0 ? newEmbeds.length - 1 : 0;
        }
        setAppState(prevState => ({ ...prevState, embeds: newEmbeds, currentEmbedIndex: newCurrentIndex }));
      };

      const addField = () => {
        const newEmbeds = [...embeds];
        const currentFields = newEmbeds[currentEmbedIndex].fields || [];
        newEmbeds[currentEmbedIndex].fields = [...currentFields, { name: '', value: '', inline: false }];
        setAppState(prevState => ({ ...prevState, embeds: newEmbeds }));
      };

      const removeField = (fieldIndex) => {
        const newEmbeds = [...embeds];
        newEmbeds[currentEmbedIndex].fields = newEmbeds[currentEmbedIndex].fields.filter((_, i) => i !== fieldIndex);
        setAppState(prevState => ({ ...prevState, embeds: newEmbeds }));
      };

      // State management for components (buttons/select menus)
      const addComponent = () => {
        setAppState(prevState => ({
          ...prevState,
          components: [...prevState.components, { type: 'button', label: '', customId: '', style: 1, url: '' }]
        }));
      };

      const removeComponent = (index) => {
        const newComponents = components.filter((_, i) => i !== index);
        setAppState(prevState => ({ ...prevState, components: newComponents }));
      };

      const handleComponentChange = (index, field, value) => {
        const newComponents = [...components];
        newComponents[index] = { ...newComponents[index], [field]: value };
        setAppState(prevState => ({ ...prevState, newComponents }));
      };
      
      const handleFileChange = (e) => {
        setAppState(prevState => ({ ...prevState, file: e.target.files[0] }));
      };

      // Function to send the webhook with detailed logging and robust data cleaning
      const sendWebhook = async () => {
        console.log("Starting webhook send process...");

        if (!webhookUrl || !isWebhookValid) {
          console.error("Validation failed: Webhook URL is not valid or is empty.");
          setAppState(prevState => ({ ...prevState, statusMessage: "Please enter a valid Webhook URL." }));
          return;
        }

        // --- Start of Robust Data Cleaning ---
        const cleanedEmbeds = [];
        for (const embed of embeds) {
          const cleanedFields = [];
          for (const field of embed.fields || []) {
            // Check for valid field name and value
            if (field.name && field.name.trim() !== '' && field.value && field.value.trim() !== '') {
              cleanedFields.push(field);
            } else {
              console.warn("Skipping invalid field:", field);
            }
          }

          // Check if embed itself has any meaningful content
          if (embed.title || embed.description || embed.url || cleanedFields.length > 0) {
            cleanedEmbeds.push({
              ...embed,
              fields: cleanedFields,
            });
          } else {
            console.warn("Skipping empty embed:", embed);
          }
        }
        
        // Final payload construction
        const payload = {
          content: messageContent,
          username: username,
          avatar_url: avatarUrl,
          tts: tts,
          // Only include embeds and components if they have valid content
          ...(cleanedEmbeds.length > 0 && { embeds: cleanedEmbeds }),
          ...(components.length > 0 && {
            components: components.map(c => ({
              type: 1, // ActionRow
              components: [{
                type: c.type === 'button' ? 2 : 3, // Button or Select Menu
                style: c.style,
                label: c.label,
                url: c.url,
                custom_id: c.customId
              }]
            }))
          })
        };

        // If the payload has no content, embeds, or components, warn the user
        if (!payload.content && (!payload.embeds || payload.embeds.length === 0) && (!payload.components || payload.components.length === 0)) {
          setAppState(prevState => ({ ...prevState, statusMessage: "Payload is empty. Please add content, embeds, or components." }));
          return;
        }

        console.log("Final payload to be sent:", payload);

        let body;
        let headers = {};
        
        // Check if there is a file to send
        if (file) {
          const formData = new FormData();
          formData.append('payload_json', JSON.stringify(payload));
          formData.append('file', file);
          body = formData;
          console.log("Preparing to send with FormData because a file is present.");
        } else {
          body = JSON.stringify(payload);
          headers['Content-Type'] = 'application/json';
          console.log("Preparing to send with JSON body.");
        }

        setAppState(prevState => ({ ...prevState, statusMessage: "Sending..." }));
        
        try {
          const url = new URL(webhookUrl);
          if (threadId) {
            url.searchParams.append('thread_id', threadId);
          }
          if (messageId) {
            url.searchParams.append('wait', 'true');
          }
          
          console.log("Sending POST request to:", url.href);

          const response = await fetch(url.href, {
            method: 'POST',
            headers: headers,
            body: body,
          });

          if (response.ok) {
            console.log("Webhook sent successfully!");
            const data = await response.json();
            console.log("Response data:", data);
            setAppState(prevState => ({ ...prevState, statusMessage: "Webhook sent successfully!" }));
          } else {
            const errorText = await response.text();
            console.error(`Webhook failed with status ${response.status}: ${response.statusText}`);
            console.error("Detailed error response:", errorText);
            setAppState(prevState => ({ ...prevState, statusMessage: `Error sending webhook: ${response.status} ${response.statusText}. Details: ${errorText}` }));
          }
        } catch (error) {
          console.error("An unhandled network or API error occurred:", error);
          setAppState(prevState => ({ ...prevState, statusMessage: `Failed to send webhook. Check the URL and try again.` }));
        }
      };

      // Function to generate and play TTS audio
      const generateTTS = async () => {
        if (!messageContent) {
          setAppState(prevState => ({ ...prevState, statusMessage: "Please enter a message to generate TTS." }));
          return;
        }

        const payload = {
          contents: [{
            parts: [{ text: messageContent }]
          }],
          generationConfig: {
            responseModality: "AUDIO",
            speechConfig: {
              voiceConfig: {
                prebuiltVoiceConfig: { voiceName: "Kore" }
              }
            }
          },
          model: "gemini-2.5-flash-preview-tts"
        };
        const apiKey = ""; // Canvas will provide this
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
        
        setAppState(prevState => ({ ...prevState, statusMessage: "Generating TTS audio..." }));
        try {
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            throw new Error(`API request failed with status: ${response.status}`);
          }

          const result = await response.json();
          const part = result?.candidates?.[0]?.content?.parts?.[0];
          const audioData = part?.inlineData?.data;
          const mimeType = part?.inlineData?.mimeType;
          
          if (audioData && mimeType && mimeType.startsWith("audio/")) {
            const pcmData = atob(audioData);
            const pcmBuffer = new ArrayBuffer(pcmData.length);
            const pcmView = new Uint8Array(pcmBuffer);
            for (let i = 0; i < pcmData.length; i++) {
              pcmView[i] = pcmData.charCodeAt(i);
            }

            const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
            const pcm16 = new Int16Array(pcmBuffer.buffer);
            const wavBlob = pcmToWav(pcm16, sampleRate);
            const audioUrl = URL.createObjectURL(wavBlob);
            
            const audio = new Audio(audioUrl);
            audio.play();
            setAppState(prevState => ({ ...prevState, statusMessage: "TTS audio is playing..." }));
            audio.onended = () => setAppState(prevState => ({ ...prevState, statusMessage: "TTS playback finished." }));

          } else {
            setAppState(prevState => ({ ...prevState, statusMessage: "TTS generation failed. No audio data received." }));
          }

        } catch (error) {
          console.error("Error generating or playing TTS:", error);
          setAppState(prevState => ({ ...prevState, statusMessage: `TTS Error: ${error.message}` }));
        }
      };

      // Helper function to convert PCM to WAV format
      const pcmToWav = (pcm16, sampleRate) => {
        const dataLength = pcm16.length * 2; // 16-bit PCM
        const buffer = new ArrayBuffer(44 + dataLength);
        const view = new DataView(buffer);

        let offset = 0;

        // RIFF header
        writeString(view, offset, 'RIFF');
        offset += 4;
        view.setUint32(offset, 36 + dataLength, true);
        offset += 4;
        writeString(view, offset, 'WAVE');
        offset += 4;

        // fmt sub-chunk
        writeString(view, offset, 'fmt ');
        offset += 4;
        view.setUint32(offset, 16, true);
        offset += 4;
        view.setUint16(offset, 1, true); // AudioFormat: PCM
        offset += 2;
        view.setUint16(offset, 1, true); // NumChannels
        offset += 2;
        view.setUint32(offset, sampleRate, true); // SampleRate
        offset += 4;
        view.setUint32(offset, sampleRate * 2, true); // ByteRate
        offset += 4;
        view.setUint16(offset, 2, true); // BlockAlign
        offset += 2;
        view.setUint16(offset, 16, true); // BitsPerSample
        offset += 2;

        // data sub-chunk
        writeString(view, offset, 'data');
        offset += 4;
        view.setUint32(offset, dataLength, true);
        offset += 4;

        // Write PCM data
        for (let i = 0; i < pcm16.length; i++, offset += 2) {
          view.setInt16(offset, pcm16[i], true);
        }

        return new Blob([view], { type: 'audio/wav' });
      };

      const writeString = (view, offset, string) => {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      };

      // Function to parse and render Markdown to HTML
      const renderMarkdown = (text) => {
        if (!text) return '';
        let html = text;
        // Convert bold markdown (**text** or __text__) to <strong>
        html = html.replace(/\*\*(.*?)\*\*|__(.*?)__/g, '<strong>$1$2</strong>');
        // Convert heading (# text) to <h1>
        html = html.replace(/^#\s(.+)/gm, '<h1 class="text-xl font-bold">$1</h1>');
        return html;
      };

      // State for the Message/Embed preview
      const previewEmbed = embeds[currentEmbedIndex] || {};

      // Voice message recording functions
      const startRecording = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const newRecorder = new MediaRecorder(stream);
          let audioChunks = [];
          newRecorder.ondataavailable = event => {
            audioChunks.push(event.data);
          };
          newRecorder.onstop = () => {
            const newAudioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            setAppState(prevState => ({ ...prevState, audioBlob: newAudioBlob, audioFile: newAudioBlob, statusMessage: "Recording stopped. Audio saved." }));
            stream.getTracks().forEach(track => track.stop());
          };
          newRecorder.start();
          setAppState(prevState => ({ ...prevState, recorder: newRecorder, isRecording: true, statusMessage: "Recording started..." }));
        } catch (err) {
          console.error('Failed to start recording:', err);
          setAppState(prevState => ({ ...prevState, statusMessage: "Error: Failed to start recording. Ensure you have a microphone." }));
        }
      };
      
      const stopRecording = () => {
        if (recorder) {
          recorder.stop();
          setAppState(prevState => ({ ...prevState, isRecording: false }));
        }
      };

      const playAudio = () => {
        if (audioBlob) {
          const audioUrl = URL.createObjectURL(audioBlob);
          const audio = new Audio(audioUrl);
          audio.play();
          setAppState(prevState => ({ ...prevState, statusMessage: "Playing voice message..." }));
          audio.onended = () => setAppState(prevState => ({ ...prevState, statusMessage: "Voice message playback finished." }));
        }
      };

      // Choose which username and avatar to display
      const displayUsername = liveUsername || username || 'MysticHook';
      const displayAvatarUrl = avatarUrl || liveAvatarUrl || '';
      
      return (
        <div className="flex flex-col lg:flex-row h-full min-h-screen bg-gray-900 text-gray-100 p-4 lg:p-8">
          {/* Left Panel: Controls */}
          <div className="w-full lg:w-1/2 p-4 bg-gray-800 rounded-xl shadow-lg mb-8 lg:mb-0 lg:mr-4 overflow-y-auto">
            <h1 className="text-3xl font-extrabold text-blue-400 mb-6 flex items-center">
              <img src={mysticHookIconUrl} alt="MysticHook Icon" className="w-8 h-8 mr-3"/>
              MysticHook
            </h1>
            <p className="text-gray-400 mb-6 text-sm">Create and customize Discord webhook messages with rich embeds and components.</p>

            {/* General Settings */}
            <div className="bg-gray-700 p-4 rounded-lg mb-6">
              <h2 className="text-xl font-bold mb-3 text-white">General Settings</h2>
              <div className="space-y-4">
                <InputGroup
                  label="Webhook URL"
                  value={webhookUrl}
                  onChange={(e) => setAppState(prevState => ({ ...prevState, webhookUrl: e.target.value }))}
                  type="url"
                  placeholder="https://discord.com/api/webhooks/..."
                  required
                  isValid={isWebhookValid}
                />
                <InputGroup label="Username" value={username} onChange={(e) => setAppState(prevState => ({ ...prevState, username: e.target.value }))} placeholder="MysticHook" />
                <InputGroup label="Avatar URL" value={avatarUrl} onChange={(e) => setAppState(prevState => ({ ...prevState, avatarUrl: e.target.value }))} type="url" placeholder="https://..." />
                <InputGroup label="Message Content" value={messageContent} onChange={(e) => setAppState(prevState => ({ ...prevState, messageContent: e.target.value }))} type="textarea" placeholder="Hello, this is my webhook message!" />
                <InputGroup label="Thread ID (Optional)" value={threadId} onChange={(e) => setAppState(prevState => ({ ...prevState, threadId: e.target.value }))} placeholder="e.g. 1234567890" />
                <div className="flex items-center">
                  <input type="checkbox" id="ttsCheckbox" checked={tts} onChange={(e) => setAppState(prevState => ({ ...prevState, tts: e.target.checked }))} className="form-checkbox h-5 w-5 text-blue-600 rounded" />
                  <label htmlFor="ttsCheckbox" className="ml-2 text-gray-300">Text-to-Speech (TTS)</label>
                </div>
              </div>
            </div>

            {/* Embeds Section */}
            <div className="bg-gray-700 p-4 rounded-lg mb-6">
              <h2 className="text-xl font-bold mb-3 text-white flex justify-between items-center">
                Embeds ({embeds.length})
                <button onClick={addEmbed} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-full transition-colors duration-200">
                  + Add
                </button>
              </h2>
              {embeds.length > 0 && (
                <div className="space-y-4">
                  <div className="flex space-x-2 overflow-x-auto pb-2">
                    {embeds.map((_, index) => (
                      <button
                        key={index}
                        onClick={() => setAppState(prevState => ({ ...prevState, currentEmbedIndex: index }))}
                        className={`px-4 py-2 rounded-lg transition-colors duration-200 ${
                          currentEmbedIndex === index ? 'bg-blue-600 text-white' : 'bg-gray-600 hover:bg-gray-500 text-gray-300'
                        }`}
                      >
                        Embed {index + 1}
                      </button>
                    ))}
                  </div>
                  {embeds[currentEmbedIndex] && (
                    <div className="p-4 bg-gray-600 rounded-lg">
                      <div className="flex justify-between items-center mb-4">
                        <h3 className="text-lg font-semibold text-white">Embed {currentEmbedIndex + 1}</h3>
                        <button onClick={() => removeEmbed(currentEmbedIndex)} className="text-red-400 hover:text-red-500">
                          <i className="fas fa-trash-alt"></i>
                        </button>
                      </div>
                      <div className="space-y-4">
                        <InputGroup label="Title" value={embeds[currentEmbedIndex].title || ''} onChange={(e) => handleEmbedChange('title', e.target.value)} placeholder="Embed Title" />
                        <InputGroup label="Description" value={embeds[currentEmbedIndex].description || ''} onChange={(e) => handleEmbedChange('description', e.target.value)} type="textarea" placeholder="Embed Description" />
                        <InputGroup label="URL" value={embeds[currentEmbedIndex].url || ''} onChange={(e) => handleEmbedChange('url', e.target.value)} type="url" placeholder="https://..." />
                        <InputGroup label="Color" value={embeds[currentEmbedIndex].color || ''} onChange={(e) => handleEmbedChange('color', e.target.value)} type="color" />
                        
                        {/* Fields Section */}
                        <div className="bg-gray-500 p-4 rounded-lg">
                          <div className="flex justify-between items-center mb-3">
                            <h4 className="font-semibold text-white">Fields</h4>
                            <button onClick={addField} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-full transition-colors duration-200 text-sm">
                              + Add Field
                            </button>
                          </div>
                          {(embeds[currentEmbedIndex].fields || []).map((field, fieldIndex) => (
                            <div key={fieldIndex} className="bg-gray-400 p-3 rounded-lg mb-2 last:mb-0">
                              <div className="flex justify-between items-center mb-2">
                                <span className="text-sm font-medium text-gray-800">Field {fieldIndex + 1}</span>
                                <button onClick={() => removeField(fieldIndex)} className="text-red-600 hover:text-red-700">
                                  <i className="fas fa-times"></i>
                                </button>
                              </div>
                              <InputGroup label="Name" value={field.name} onChange={(e) => handleFieldChange(fieldIndex, 'name', e.target.value)} placeholder="Field Name" />
                              <InputGroup label="Value" value={field.value} onChange={(e) => handleFieldChange(fieldIndex, 'value', e.target.value)} type="textarea" placeholder="Field Value" />
                              <div className="flex items-center mt-2">
                                <input type="checkbox" id={`inline-${currentEmbedIndex}-${fieldIndex}`} checked={field.inline} onChange={(e) => handleFieldChange(fieldIndex, 'inline', e.target.checked)} className="form-checkbox h-4 w-4 text-blue-600 rounded" />
                                <label htmlFor={`inline-${currentEmbedIndex}-${fieldIndex}`} className="ml-2 text-gray-800 text-sm">Inline</label>
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>

            {/* Components Section */}
            <div className="bg-gray-700 p-4 rounded-lg mb-6">
              <h2 className="text-xl font-bold mb-3 text-white flex justify-between items-center">
                Components ({components.length})
                <button onClick={addComponent} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-full transition-colors duration-200">
                  + Add
                </button>
              </h2>
              {components.map((component, index) => (
                <div key={index} className="bg-gray-600 p-4 rounded-lg mb-4">
                  <div className="flex justify-between items-center mb-3">
                    <h3 className="text-lg font-semibold text-white">Component {index + 1}</h3>
                    <button onClick={() => removeComponent(index)} className="text-red-400 hover:text-red-500">
                      <i className="fas fa-trash-alt"></i>
                    </button>
                  </div>
                  <div className="space-y-3">
                    <InputGroup label="Type" value={component.type} onChange={(e) => handleComponentChange(index, 'type', e.target.value)} type="select">
                      <option value="button">Button</option>
                      {/* Select menus can be added here if needed */}
                    </InputGroup>
                    <InputGroup label="Label" value={component.label} onChange={(e) => handleComponentChange(index, 'label', e.target.value)} placeholder="Button Label" />
                    <InputGroup label="Style" value={component.style} onChange={(e) => handleComponentChange(index, 'style', e.target.value)} type="select">
                      <option value="1">Primary</option>
                      <option value="2">Secondary</option>
                      <option value="3">Success</option>
                      <option value="4">Danger</option>
                      <option value="5">Link</option>
                    </InputGroup>
                    <InputGroup label="Custom ID" value={component.customId} onChange={(e) => handleComponentChange(index, 'customId', e.target.value)} placeholder="custom_id" />
                    {component.style == 5 && (
                      <InputGroup label="URL" value={component.url} onChange={(e) => handleComponentChange(index, 'url', e.target.value)} type="url" placeholder="https://..." />
                    )}
                  </div>
                </div>
              ))}
            </div>

            {/* File Upload Section */}
            <div className="bg-gray-700 p-4 rounded-lg mb-6">
              <h2 className="text-xl font-bold mb-3 text-white">File Upload</h2>
              <input type="file" onChange={handleFileChange} className="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-500 file:text-white hover:file:bg-blue-600"/>
              {file && (
                <p className="mt-2 text-sm text-gray-400">Selected file: {file.name}</p>
              )}
            </div>
            
            {/* Audio Recording Section */}
            <div className="bg-gray-700 p-4 rounded-lg mb-6 flex flex-col items-center">
              <h2 className="text-xl font-bold mb-3 text-white">Voice Message</h2>
              <div className="flex items-center space-x-4">
                <button
                  onClick={isRecording ? stopRecording : startRecording}
                  className={`py-3 px-6 rounded-full text-white font-bold transition-all duration-300 ease-in-out transform hover:scale-105 ${isRecording ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600'}`}
                >
                  {isRecording ? <i className="fas fa-stop"></i> : <i className="fas fa-microphone"></i>}
                  <span className="ml-2">{isRecording ? 'Stop Recording' : 'Start Recording'}</span>
                </button>
                {audioBlob && (
                  <button onClick={playAudio} className="py-3 px-6 rounded-full bg-blue-500 hover:bg-blue-600 text-white font-bold transition-transform duration-300 ease-in-out transform hover:scale-105">
                    <i className="fas fa-play"></i>
                    <span className="ml-2">Play</span>
                  </button>
                )}
              </div>
            </div>

            {/* Action Buttons */}
            <div className="flex flex-col space-y-4">
              <button
                onClick={sendWebhook}
                className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-xl transition-transform duration-200 transform hover:scale-105 shadow-xl"
              >
                Send Webhook
              </button>
              <button
                onClick={generateTTS}
                className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-xl transition-transform duration-200 transform hover:scale-105 shadow-xl"
              >
                Generate TTS
              </button>
            </div>

            {/* Status Message */}
            <div className="mt-6 text-center text-sm font-semibold text-gray-400">
              {statusMessage}
            </div>
          </div>

          {/* Right Panel: Preview */}
          <div className="w-full lg:w-1/2 p-4 bg-gray-800 rounded-xl shadow-lg relative">
            <h2 className="text-xl font-bold text-white mb-4">Live Preview</h2>
            <div className="bg-gray-900 rounded-xl p-4 min-h-[400px]">
              <div className="flex items-start mb-2">
                {/* Avatar Preview */}
                <div className="w-12 h-12 rounded-full mr-4 flex-shrink-0">
                  {isAvatarLoading ? (
                    <div className="w-full h-full rounded-full bg-gray-600 animate-pulse"></div>
                  ) : (
                    <img
                      src={displayAvatarUrl || defaultAvatarSvg}
                      alt="Avatar"
                      className="w-full h-full rounded-full object-cover"
                      onError={(e) => {
                          e.target.src = defaultAvatarSvg;
                      }}
                    />
                  )}
                </div>
                <div>
                  <div className="flex items-baseline">
                    <span className="font-bold text-lg mr-2 text-blue-400">{displayUsername}</span>
                    <span className="text-xs text-gray-500">BOT</span>
                  </div>
                  {/* Using dangerouslySetInnerHTML to render Markdown as HTML */}
                  {messageContent && (
                    <div
                      className="text-gray-300 mt-1 markdown-content"
                      dangerouslySetInnerHTML={{ __html: renderMarkdown(messageContent) }}
                    />
                  )}
                  {audioBlob && (
                    <div className="mt-2 p-2 bg-gray-700 rounded-lg flex items-center justify-between">
                      <span className="text-sm">Voice Message Ready</span>
                      <button onClick={playAudio} className="text-blue-400 hover:text-blue-500">
                        <i className="fas fa-play-circle text-xl"></i>
                      </button>
                    </div>
                  )}
                </div>
              </div>
              
              {/* Embed Preview */}
              {(embeds.length > 0) && (
                <div className="mt-4 border-l-4 rounded-md p-3 relative" style={{ borderColor: previewEmbed.color || '#5865f2', backgroundColor: 'rgba(52, 58, 64, 0.4)' }}>
                  {previewEmbed.title && (
                    <a href={previewEmbed.url} target="_blank" rel="noopener noreferrer" className="font-bold text-lg text-blue-400 hover:underline">
                      {previewEmbed.title}
                    </a>
                  )}
                  {previewEmbed.description && (
                    <p className="text-sm text-gray-300 mt-2">{previewEmbed.description}</p>
                  )}
                  {(previewEmbed.fields || []).length > 0 && (
                    <div className={`mt-2 ${previewEmbed.fields.some(f => f.inline) ? 'flex flex-wrap' : 'block'}`}>
                      {(previewEmbed.fields || []).map((field, index) => (
                        <div key={index} className={`mb-2 ${field.inline ? 'w-1/2 pr-2' : 'w-full'}`}>
                          <h4 className="font-semibold text-white">{field.name}</h4>
                          <p className="text-sm text-gray-300 whitespace-pre-wrap">{field.value}</p>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              )}

              {/* Components Preview */}
              {components.length > 0 && (
                <div className="mt-4 flex flex-wrap gap-2">
                  {components.map((component, index) => (
                    <button
                      key={index}
                      className={`px-4 py-2 rounded-lg font-semibold transition-colors duration-200 transform hover:scale-105 shadow-md
                        ${component.style == 1 ? 'bg-blue-600 text-white hover:bg-blue-700' : ''}
                        ${component.style == 2 ? 'bg-gray-500 text-white hover:bg-gray-600' : ''}
                        ${component.style == 3 ? 'bg-green-600 text-white hover:bg-green-700' : ''}
                        ${component.style == 4 ? 'bg-red-600 text-white hover:bg-red-700' : ''}
                        ${component.style == 5 ? 'text-blue-400 border border-blue-400 hover:bg-blue-400 hover:text-white' : ''}
                      `}
                    >
                      {component.label}
                    </button>
                  ))}
                </div>
              )}
            </div>
          </div>
        </div>
      );
    };

    const InputGroup = ({ label, value, onChange, type = 'text', placeholder, required = false, children, isValid }) => {
      const inputId = label.toLowerCase().replace(/\s/g, '-');
      const inputClass = "w-full p-2 rounded-md bg-gray-600 text-white border border-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500";
      
      let inputElement;
      if (type === 'textarea') {
        inputElement = (
          <textarea
            id={inputId}
            value={value}
            onChange={onChange}
            placeholder={placeholder}
            required={required}
            className={`${inputClass} h-24 resize-none`}
          />
        );
      } else if (type === 'select') {
        inputElement = (
          <select
            id={inputId}
            value={value}
            onChange={onChange}
            className={inputClass}
          >
            {children}
          </select>
        );
      } else if (type === 'color') {
        inputElement = (
          <div className="flex items-center">
            <input
              type="color"
              id={inputId}
              value={value}
              onChange={onChange}
              className="w-12 h-12 p-1 rounded-md border-2 border-gray-500"
            />
            <input
              type="text"
              value={value}
              onChange={onChange}
              placeholder="#5865f2"
              className="ml-4 flex-grow p-2 rounded-md bg-gray-600 text-white border border-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
        );
      } else {
        inputElement = (
          <div className="relative">
            <input
              type={type}
              id={inputId}
              value={value}
              onChange={onChange}
              placeholder={placeholder}
              required={required}
              className={inputClass}
            />
            {label === 'Webhook URL' && value.length > 0 && (
              <span className="absolute right-3 top-1/2 transform -translate-y-1/2">
                {isValid ? (
                  <i className="fas fa-check-circle text-green-400" title="Valid Webhook URL"></i>
                ) : (
                  <i className="fas fa-exclamation-circle text-red-400" title="Invalid Webhook URL"></i>
                )}
              </span>
            )}
          </div>
        );
      }

      return (
        <div className="flex flex-col">
          <label htmlFor={inputId} className="mb-1 text-sm font-medium text-gray-300">
            {label}
          </label>
          {inputElement}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);

  </script>
</body>
</html>

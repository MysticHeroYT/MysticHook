<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MysticHook</title>
  <!-- Load Tailwind CSS via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Load Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" xintegrity="sha512-Fo3rlrZj/k7sLw/dZt3Rz5sP/dZt3Rz5sP/f6KkF58pG9pGgG8+2pP+jJk2U2lK4yUu3QzB6K8CgC8vJ7vTf8lE/pL0NqP6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <!-- Custom Favicon (inline SVG) -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M50 0 C77.6 0 100 22.4 100 50 C100 77.6 77.6 100 50 100 C22.4 100 0 77.6 0 50 C0 22.4 22.4 0 50 0 Z' fill='%235865f2'/%3E%3Cpath d='M30 65 L45 80 L70 55 L55 40 Z' fill='%23fff'/%3E%3C/svg%3E">
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #1a202c;
    }
    .embed-preview {
        border-left-color: var(--embed-color);
    }
  </style>
</head>
<body class="bg-gray-900 text-white">
  <div id="root"></div>

  <!-- Corrected script loading order -->
  <!-- 1. Load React and ReactDOM from CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- 2. Load Babel Standalone to transpile the JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
  <!-- 3. The main React app script with type="text/babel" -->
  <script type="text/babel">
    const { useState, useEffect } = React;

    // Helper component for styled form inputs
    const InputGroup = ({ label, value, onChange, type = 'text', placeholder, isValid, required, children }) => (
      <div>
        <label className="block text-sm font-medium text-gray-300 mb-1">
          {label}
          {required && <span className="text-red-400">*</span>}
        </label>
        {type === 'textarea' ? (
          <textarea
            value={value}
            onChange={onChange}
            placeholder={placeholder}
            className="w-full p-2 rounded-md bg-gray-600 border border-transparent focus:border-blue-500 focus:outline-none resize-y"
          ></textarea>
        ) : type === 'select' ? (
          <select
            value={value}
            onChange={onChange}
            className="w-full p-2 rounded-md bg-gray-600 border border-transparent focus:border-blue-500 focus:outline-none"
          >
            {children}
          </select>
        ) : type === 'color' ? (
          <input
            type="color"
            value={value}
            onChange={onChange}
            className="w-full h-10 p-1 rounded-md bg-gray-600 border border-transparent focus:border-blue-500 focus:outline-none"
          />
        ) : (
          <input
            type={type}
            value={value}
            onChange={onChange}
            placeholder={placeholder}
            className={`w-full p-2 rounded-md bg-gray-600 border ${
              isValid === false ? 'border-red-500' : 'border-transparent'
            } focus:border-blue-500 focus:outline-none`}
          />
        )}
      </div>
    );
    
    // Custom SVG icon as a data URL
    const mysticHookIconUrl = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M50 0 C77.6 0 100 22.4 100 50 C100 77.6 77.6 100 50 100 C22.4 100 0 77.6 0 50 C0 22.4 22.4 0 50 0 Z' fill='%235865f2'/%3E%3Cpath d='M30 65 L45 80 L70 55 L55 40 Z' fill='%23fff'/%3E%3C/svg%3E";

    // Fallback avatar as an inline SVG
    const defaultAvatarSvg = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white" width="48px" height="48px"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>`;

    // Initial state for the app, now with an empty embeds array
    const initialAppState = {
      embeds: [],
      currentEmbedIndex: 0,
      components: [],
      messageContent: 'Made by MysticHero',
      username: 'MysticHook',
      avatarUrl: '',
      webhookUrl: '',
      isWebhookValid: false,
      tts: false,
      threadId: '',
      messageId: '',
      file: null,
      audioFile: null,
      isRecording: false,
      recorder: null,
      statusMessage: '',
      liveUsername: '',
      liveAvatarUrl: '',
      audioBlob: null,
      isAvatarLoading: false
    };

    const App = () => {
      // Core webhook state
      const [appState, setAppState] = useState(initialAppState);

      // Destructure state for easier access
      const { 
        embeds, currentEmbedIndex, components, messageContent, username, avatarUrl,
        webhookUrl, isWebhookValid, tts, threadId, messageId, file, audioFile,
        isRecording, recorder, statusMessage, liveUsername, liveAvatarUrl, audioBlob,
        isAvatarLoading
      } = appState;

      // Effect to validate the webhook URL and fetch its info
      useEffect(() => {
        const isValid = webhookUrl.startsWith('https://discord.com/api/webhooks/');
        setAppState(prevState => ({ ...prevState, isWebhookValid: isValid }));
        
        if (isValid) {
          setAppState(prevState => ({ ...prevState, isAvatarLoading: true }));
          fetch(webhookUrl, { method: 'GET' })
            .then(response => {
              if (response.ok) {
                return response.json();
              } else {
                throw new Error('Failed to fetch webhook data');
              }
            })
            .then(data => {
              const newLiveUsername = data.name;
              const avatar = data.avatar;
              let newLiveAvatarUrl = '';
              if (avatar) {
                const extension = avatar.startsWith('a_') ? 'gif' : 'png';
                newLiveAvatarUrl = `https://cdn.discordapp.com/avatars/${data.id}/${avatar}.${extension}`;
              }
              setAppState(prevState => ({ 
                ...prevState, 
                liveUsername: newLiveUsername, 
                liveAvatarUrl: newLiveAvatarUrl,
                isAvatarLoading: false
              }));
            })
            .catch(error => {
              console.error("Error fetching webhook info:", error);
              setAppState(prevState => ({ ...prevState, liveUsername: '', liveAvatarUrl: '', isAvatarLoading: false }));
            });
        } else {
          setAppState(prevState => ({ ...prevState, liveUsername: '', liveAvatarUrl: '' }));
        }
      }, [webhookUrl]);
      
      // Function to clear all data and reset to initial state
      const clearAllData = () => {
        setAppState(initialAppState);
      };

      // State management for embeds and fields
      const handleEmbedChange = (field, value) => {
        const newEmbeds = [...embeds];
        newEmbeds[currentEmbedIndex] = { ...newEmbeds[currentEmbedIndex], [field]: value };
        setAppState(prevState => ({ ...prevState, embeds: newEmbeds }));
      };

      const handleFieldChange = (fieldIndex, fieldName, value) => {
        const newEmbeds = [...embeds];
        const newFields = [...(newEmbeds[currentEmbedIndex].fields || [])];
        if (!newFields[fieldIndex]) {
          newFields[fieldIndex] = {};
        }
        newFields[fieldIndex][fieldName] = value;
        newEmbeds[currentEmbedIndex].fields = newFields;
        setAppState(prevState => ({ ...prevState, embeds: newEmbeds }));
      };

      const addEmbed = () => {
        setAppState(prevState => ({ 
          ...prevState, 
          embeds: [...prevState.embeds, { title: '', description: '', color: '', fields: [] }],
          currentEmbedIndex: prevState.embeds.length
        }));
      };

      const removeEmbed = (index) => {
        const newEmbeds = embeds.filter((_, i) => i !== index);
        let newCurrentIndex = currentEmbedIndex;
        if (newCurrentIndex >= newEmbeds.length) {
          newCurrentIndex = newEmbeds.length > 0 ? newEmbeds.length - 1 : 0;
        }
        setAppState(prevState => ({ ...prevState, embeds: newEmbeds, currentEmbedIndex: newCurrentIndex }));
      };

      const addField = () => {
        const newEmbeds = [...embeds];
        const currentFields = newEmbeds[currentEmbedIndex].fields || [];
        newEmbeds[currentEmbedIndex].fields = [...currentFields, { name: '', value: '', inline: false }];
        setAppState(prevState => ({ ...prevState, embeds: newEmbeds }));
      };

      const removeField = (fieldIndex) => {
        const newEmbeds = [...embeds];
        newEmbeds[currentEmbedIndex].fields = newEmbeds[currentEmbedIndex].fields.filter((_, i) => i !== fieldIndex);
        setAppState(prevState => ({ ...prevState, embeds: newEmbeds }));
      };

      // State management for components (buttons/select menus)
      const addComponent = () => {
        setAppState(prevState => ({
          ...prevState,
          components: [...prevState.components, { type: 'button', label: '', style: 1, custom_id: '', url: '' }]
        }));
      };

      const removeComponent = (index) => {
        const newComponents = components.filter((_, i) => i !== index);
        setAppState(prevState => ({ ...prevState, components: newComponents }));
      };

      const handleComponentChange = (index, field, value) => {
        const newComponents = [...components];
        newComponents[index] = { ...newComponents[index], [field]: value };
        setAppState(prevState => ({ ...prevState, components: newComponents }));
      };
      
      const handleFileChange = (e) => {
        setAppState(prevState => ({ ...prevState, file: e.target.files[0] }));
      };

      // Function to send the webhook with detailed logging and robust data cleaning
      const sendWebhook = async () => {
        console.log("Starting webhook send process...");

        if (!webhookUrl || !isWebhookValid) {
          console.error("Validation failed: Webhook URL is not valid or is empty.");
          setAppState(prevState => ({ ...prevState, statusMessage: "Please enter a valid Webhook URL." }));
          return;
        }

        // --- Start of Robust Data Cleaning ---
        const cleanedEmbeds = [];
        for (const embed of embeds) {
          const cleanedFields = [];
          for (const field of embed.fields || []) {
            // Check for valid field name and value
            if (field.name && field.name.trim() !== '' && field.value && field.value.trim() !== '') {
              cleanedFields.push(field);
            } else {
              console.warn("Skipping invalid field:", field);
            }
          }

          // Check if embed itself has any meaningful content
          if (embed.title || embed.description || embed.url || cleanedFields.length > 0) {
            cleanedEmbeds.push({
              ...embed,
              fields: cleanedFields,
            });
          } else {
            console.warn("Skipping empty embed:", embed);
          }
        }
        
        // Clean and prepare components for the payload
        const cleanedComponents = components.map(c => {
          if (c.style == 5) {
            // Link button
            return {
              type: 2,
              style: c.style,
              label: c.label,
              url: c.url,
            };
          } else {
            // Interactive button
            return {
              type: 2,
              style: c.style,
              label: c.label,
              custom_id: c.custom_id,
            };
          }
        });
        
        // Final payload construction
        const payload = {
          content: messageContent,
          username: username,
          avatar_url: avatarUrl,
          tts: tts,
          // Only include embeds and components if they have valid content
          ...(cleanedEmbeds.length > 0 && { embeds: cleanedEmbeds }),
          ...(cleanedComponents.length > 0 && {
            components: [{
              type: 1, // ActionRow
              components: cleanedComponents
            }]
          })
        };

        // If the payload has no content, embeds, or components, warn the user
        if (!payload.content && (!payload.embeds || payload.embeds.length === 0) && (!payload.components || payload.components.length === 0) && !file && !audioFile) {
          setAppState(prevState => ({ ...prevState, statusMessage: "Payload is empty. Please add content, embeds, or components." }));
          return;
        }

        console.log("Final payload to be sent:", payload);

        let body;
        let headers = {};
        
        // Check if there is a file to send
        if (file || audioFile) {
          const formData = new FormData();
          formData.append('payload_json', JSON.stringify(payload));
          if (file) {
            formData.append('file', file);
          }
          if (audioFile) {
            formData.append('file', audioFile, 'voice_message.webm');
          }
          body = formData;
          console.log("Preparing to send with FormData because a file is present.");
        } else {
          body = JSON.stringify(payload);
          headers['Content-Type'] = 'application/json';
          console.log("Preparing to send with JSON body.");
        }

        setAppState(prevState => ({ ...prevState, statusMessage: "Sending..." }));
        
        try {
          const url = new URL(webhookUrl);
          if (threadId) {
            url.searchParams.append('thread_id', threadId);
          }
          if (messageId) {
            url.searchParams.append('wait', 'true');
          }
          
          console.log("Sending POST request to:", url.href);

          const response = await fetch(url.href, {
            method: 'POST',
            headers: headers,
            body: body,
          });

          if (response.ok) {
            console.log("Webhook sent successfully!");
            setAppState(prevState => ({ ...prevState, statusMessage: "Webhook sent successfully!" }));
          } else {
            const errorText = await response.text();
            console.error(`Webhook failed with status ${response.status}: ${response.statusText}`);
            console.error("Detailed error response:", errorText);
            setAppState(prevState => ({ ...prevState, statusMessage: `Error sending webhook: ${response.status} ${response.statusText}. Details: ${errorText}` }));
          }
        } catch (error) {
          console.error("An unhandled network or API error occurred:", error);
          setAppState(prevState => ({ ...prevState, statusMessage: `Failed to send webhook. Check the URL and try again.` }));
        }
      };
      
      const Preview = () => {
        const embed = embeds[currentEmbedIndex] || {};
        const timestamp = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

        return (
          <div className="bg-gray-800 p-4 rounded-lg flex flex-col items-start gap-4 h-full">
            {/* Live Preview Header */}
            <div className="flex items-center space-x-2 w-full">
              <img
                src={liveAvatarUrl || defaultAvatarSvg}
                alt="Webhook Avatar"
                className={`w-12 h-12 rounded-full border-2 border-transparent ${isAvatarLoading ? 'animate-pulse' : ''}`}
              />
              <div className="flex-1">
                <span className="font-semibold text-white">{liveUsername || "Webhook Username"}</span>
              </div>
            </div>
            {/* Webhook Preview Message & Embeds */}
            <div className="w-full">
              {messageContent && (
                <div className="flex items-start">
                  <div className="flex flex-col">
                    <div className="flex items-baseline">
                      <span className="font-semibold text-gray-100">{username || 'MysticHook'}</span>
                      <span className="text-xs text-gray-400 ml-2">{timestamp}</span>
                    </div>
                    <p className="text-gray-200 mt-1">{messageContent}</p>
                  </div>
                </div>
              )}
              {embeds.map((e, index) => (
                <div key={index} className="flex mt-4" style={{ '--embed-color': e.color || '#5865F2' }}>
                  <div className="w-1 bg-blue-500 rounded-l-md embed-preview"></div>
                  <div className="bg-gray-700 p-4 rounded-r-md w-full shadow-lg border-l-2 border-blue-500">
                    {e.title && <h3 className="font-semibold text-lg text-white mb-1">{e.title}</h3>}
                    {e.url && <p className="text-blue-400 text-sm">{e.url}</p>}
                    {e.description && <p className="text-gray-300 text-sm mt-1">{e.description}</p>}
                    {e.fields && e.fields.length > 0 && (
                      <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-2">
                        {e.fields.map((field, fieldIndex) => (
                          <div key={fieldIndex} className="text-sm">
                            <p className="font-bold text-gray-100">{field.name}</p>
                            <p className="text-gray-300">{field.value}</p>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
              ))}
            </div>
            {/* Preview of Components */}
            {components.length > 0 && (
              <div className="w-full mt-4 flex flex-wrap gap-2">
                {components.map((comp, index) => (
                  <button
                    key={index}
                    className={`
                      px-4 py-2 rounded-md font-semibold text-sm
                      ${comp.style == 1 ? 'bg-blue-600 hover:bg-blue-700' : ''}
                      ${comp.style == 2 ? 'bg-gray-600 hover:bg-gray-500' : ''}
                      ${comp.style == 3 ? 'bg-green-600 hover:bg-green-700' : ''}
                      ${comp.style == 4 ? 'bg-red-600 hover:bg-red-700' : ''}
                      ${comp.style == 5 ? 'bg-blue-600 hover:bg-blue-700' : ''}
                    `}
                    disabled={comp.style == 5}
                  >
                    {comp.label}
                  </button>
                ))}
              </div>
            )}
          </div>
        );
      };

      const EmbedEditor = () => {
        const embed = embeds[currentEmbedIndex] || {};
        return (
          <div className="bg-gray-700 p-4 rounded-lg flex flex-col gap-4">
            <h3 className="text-lg font-bold text-gray-200">Embed {currentEmbedIndex + 1}</h3>
            <InputGroup label="Embed Title" value={embed.title || ''} onChange={e => handleEmbedChange('title', e.target.value)} />
            <InputGroup label="Embed Description" type="textarea" value={embed.description || ''} onChange={e => handleEmbedChange('description', e.target.value)} />
            <InputGroup label="Embed Color" type="color" value={embed.color || '#5865F2'} onChange={e => handleEmbedChange('color', e.target.value)} />
            <InputGroup label="Embed URL" value={embed.url || ''} onChange={e => handleEmbedChange('url', e.target.value)} />

            <div className="bg-gray-600 p-3 rounded-md">
              <h4 className="text-md font-bold text-gray-200 mb-2">Fields</h4>
              {embed.fields && embed.fields.map((field, index) => (
                <div key={index} className="bg-gray-700 p-3 rounded-md mb-2">
                  <InputGroup label="Name" value={field.name} onChange={e => handleFieldChange(index, 'name', e.target.value)} />
                  <InputGroup label="Value" type="textarea" value={field.value} onChange={e => handleFieldChange(index, 'value', e.target.value)} />
                  <button onClick={() => removeField(index)} className="mt-2 text-red-400 hover:text-red-500 transition-colors">
                    <i className="fas fa-trash-alt mr-1"></i> Remove Field
                  </button>
                </div>
              ))}
              <button onClick={addField} className="w-full mt-2 px-4 py-2 bg-blue-600 rounded-md text-white font-semibold hover:bg-blue-700 transition-colors">
                <i className="fas fa-plus mr-1"></i> Add Field
              </button>
            </div>
          </div>
        );
      };

      const ComponentEditor = () => {
        return (
          <div className="bg-gray-700 p-4 rounded-lg flex flex-col gap-4">
            <h3 className="text-lg font-bold text-gray-200">Components</h3>
            {components.map((comp, index) => (
              <div key={index} className="bg-gray-600 p-3 rounded-md">
                <div className="flex justify-between items-center mb-2">
                  <h4 className="text-md font-bold text-gray-200">Component {index + 1}</h4>
                  <button onClick={() => removeComponent(index)} className="text-red-400 hover:text-red-500 transition-colors">
                    <i className="fas fa-trash-alt"></i>
                  </button>
                </div>
                <InputGroup
                  label="Type"
                  type="select"
                  value={comp.type}
                  onChange={e => handleComponentChange(index, 'type', e.target.value)}
                >
                  <option value="button">Button</option>
                  <option value="select">Select Menu</option>
                </InputGroup>
                {comp.type === 'button' && (
                  <>
                    <InputGroup label="Label" value={comp.label} onChange={e => handleComponentChange(index, 'label', e.target.value)} />
                    <InputGroup
                      label="Style"
                      type="select"
                      value={comp.style}
                      onChange={e => handleComponentChange(index, 'style', e.target.value)}
                    >
                      <option value="1">Primary (Blue)</option>
                      <option value="2">Secondary (Gray)</option>
                      <option value="3">Success (Green)</option>
                      <option value="4">Danger (Red)</option>
                      <option value="5">Link (Redirects to URL)</option>
                    </InputGroup>
                    {comp.style == 5 ? (
                      <InputGroup label="URL" value={comp.url} onChange={e => handleComponentChange(index, 'url', e.target.value)} />
                    ) : (
                      <InputGroup label="Custom ID" value={comp.custom_id} onChange={e => handleComponentChange(index, 'custom_id', e.target.value)} />
                    )}
                  </>
                )}
              </div>
            ))}
            <button onClick={addComponent} className="w-full mt-2 px-4 py-2 bg-blue-600 rounded-md text-white font-semibold hover:bg-blue-700 transition-colors">
              <i className="fas fa-plus mr-1"></i> Add Component
            </button>
          </div>
        );
      };

      // Main render function
      return (
        <div className="bg-gray-800 p-6 rounded-2xl shadow-2xl w-full max-w-7xl border border-gray-700 flex flex-col lg:flex-row gap-8">
          {/* Left Panel: Input Fields and Controls */}
          <div className="lg:w-1/2 flex flex-col gap-6">
            
            {/* Header */}
            <div className="text-center">
              <h1 className="text-5xl font-extrabold text-blue-400 mb-2">MysticHook</h1>
              <p className="text-lg text-gray-400">Build and preview your Discord webhooks in real-time</p>
            </div>

            {/* Webhook URL Input */}
            <div className="bg-gray-700 p-4 rounded-lg flex flex-col gap-2">
              <InputGroup label="Webhook URL" type="url" placeholder="https://discord.com/api/webhooks/..." value={webhookUrl} onChange={e => setAppState(p => ({ ...p, webhookUrl: e.target.value }))} isValid={isWebhookValid || webhookUrl === ''} required />
              {!isWebhookValid && webhookUrl !== '' && (
                <p className="text-red-400 text-sm">Please enter a valid Discord webhook URL.</p>
              )}
            </div>

            {/* Main Content Fields */}
            <div className="bg-gray-700 p-4 rounded-lg flex flex-col gap-4">
              <InputGroup label="Message Content" type="textarea" placeholder="Hello, world!" value={messageContent} onChange={e => setAppState(p => ({ ...p, messageContent: e.target.value }))} />
              <div className="flex flex-col sm:flex-row gap-4">
                <div className="w-full sm:w-1/2">
                  <InputGroup label="Username" placeholder="MysticHook" value={username} onChange={e => setAppState(p => ({ ...p, username: e.target.value }))} />
                </div>
                <div className="w-full sm:w-1/2">
                  <InputGroup label="Avatar URL" type="url" placeholder="https://example.com/avatar.png" value={avatarUrl} onChange={e => setAppState(p => ({ ...p, avatarUrl: e.target.value }))} />
                </div>
              </div>
            </div>

            {/* Embed & Component Controls */}
            <div className="bg-gray-700 p-4 rounded-lg flex justify-between items-center space-x-4">
              <span className="font-semibold text-gray-300">Embeds:</span>
              <div className="flex space-x-2">
                {embeds.map((_, index) => (
                  <button key={index} onClick={() => setAppState(p => ({ ...p, currentEmbedIndex: index }))} className={`px-3 py-1 rounded-md text-sm font-bold transition-colors ${currentEmbedIndex === index ? 'bg-blue-600 text-white' : 'bg-gray-600 text-gray-300 hover:bg-gray-500'}`}>
                    {index + 1}
                  </button>
                ))}
                <button onClick={addEmbed} className="px-3 py-1 bg-green-600 rounded-md text-white font-bold text-sm hover:bg-green-700 transition-colors transform hover:scale-105">
                  <i className="fas fa-plus"></i> Add
                </button>
                {embeds.length > 0 && (
                  <button onClick={() => removeEmbed(currentEmbedIndex)} className="px-3 py-1 bg-red-600 rounded-md text-white font-bold text-sm hover:bg-red-700 transition-colors transform hover:scale-105">
                    <i className="fas fa-trash-alt"></i>
                  </button>
                )}
              </div>
            </div>

            {/* Conditional Embed or Component Editor */}
            {embeds.length > 0 && <EmbedEditor />}
            <ComponentEditor />

            {/* Action Buttons */}
            <div className="bg-gray-700 p-4 rounded-lg flex flex-col sm:flex-row justify-between items-center space-y-4 sm:space-y-0 sm:space-x-4">
                <button
                    onClick={sendWebhook}
                    className="w-full sm:w-auto px-6 py-3 rounded-lg font-bold text-white bg-blue-600 hover:bg-blue-700 transition-colors duration-200 transform hover:scale-105"
                >
                    <i className="fas fa-paper-plane mr-2"></i>
                    Send Webhook
                </button>
                <button
                    onClick={clearAllData}
                    className="w-full sm:w-auto px-6 py-3 rounded-lg font-bold text-gray-300 bg-gray-600 hover:bg-gray-500 transition-colors duration-200 transform hover:scale-105"
                >
                    <i className="fas fa-eraser mr-2"></i>
                    Clear All
                </button>
            </div>
          </div>
          
          {/* Right Panel: Live Preview */}
          <Preview />
        </div>
      );
    };

    // The root of the React app
    // Using the modern createRoot method, which is the correct way to render in React 18+
    const domNode = document.getElementById('root');
    const root = ReactDOM.createRoot(domNode);
    root.render(<App />);
  </script>
</body>
</html>
